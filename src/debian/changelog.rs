use chrono;
use textwrap::fill;

use std::fmt;
use std::iter::FromIterator;
use std::str;


pub const DEFAULT_DIST: &'static str = "FIXME-AUTOGENERATED-DEBCARGO";


pub struct Changelog<'a> {
    source: &'a str,
    version: &'a str,
    distribution: &'a str,
    urgency: &'a str,
    maintainer: &'a str,
    entries: Vec<String>,
}

impl<'a> fmt::Display for Changelog<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(
            f,
            "{} ({}) {}; urgency={}\n",
            self.source,
            self.version,
            self.distribution,
            self.urgency
        )?;

        for entry in self.entries.iter() {
            writeln!(f, "  * {}", fill(entry, 79))?;
        }

        writeln!(
            f,
            "\n -- {}  {}\n",
            self.maintainer,
            chrono::Local::now().to_rfc2822()
        )
    }
}

impl<'a> Changelog<'a> {
    pub fn new(
        src: &'a str,
        version: &'a str,
        distribution: &'a str,
        urgency: &'a str,
        maintainer: &'a str,
        entries: &[String],
    ) -> Self {
        let changelog = entries.iter().map(|x| x.to_string());
        Changelog {
            source: src,
            version: version,
            distribution: distribution,
            urgency: urgency,
            maintainer: maintainer,
            entries: Vec::from_iter(changelog),
        }
    }
}


pub struct ChangelogIterator<'a> {
    input: &'a [u8],
    index: usize,
}

impl<'a> ChangelogIterator<'a> {
    pub fn from(input: &'a str) -> ChangelogIterator<'a> {
        ChangelogIterator {
            input: input.as_bytes(),
            index: 0,
        }
    }
}

impl<'a> Iterator for ChangelogIterator<'a> {
    type Item = &'a str;

    #[inline]
    fn next(&mut self) -> Option<&'a str> {
        let slice = &self.input[self.index..];
        if slice.is_empty() {
            return None;
        }
        let mut result = slice;
        // ghetto parser; also hack around the fact rust's str doesn't
        // support proper indexing, boo
        for (i, c) in slice.iter().enumerate() {
            if *c != ('\n' as u8) {
                continue
            }
            if slice.len() >= i || (slice[i+1] as char).is_whitespace() {
                continue
            }
            self.index += i+1;
            result = &slice[..i+1];
            break
        }
        Some(str::from_utf8(&result).unwrap())
    }
}
