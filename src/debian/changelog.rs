use chrono;
use textwrap::{fill, indent};

use std::fmt;
use std::iter::FromIterator;
use std::str;

pub const DEFAULT_DIST: &'static str = "UNRELEASED-FIXME-AUTOGENERATED-DEBCARGO";

pub struct ChangelogEntry<'a> {
    source: &'a str,
    version: &'a str,
    distribution: &'a str,
    urgency: &'a str,
    maintainer: &'a str,
    items: Vec<String>,
}

impl<'a> fmt::Display for ChangelogEntry<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(
            f,
            "{} ({}) {}; urgency={}\n",
            self.source, self.version, self.distribution, self.urgency
        )?;

        for entry in self.items.iter() {
            writeln!(f, "  * {}",
                indent(&fill(entry, 75), "    ")
                    .chars().skip(4).collect::<String>().trim_right())?;
        }

        writeln!(
            f,
            "\n -- {}  {}",
            self.maintainer,
            chrono::Local::now().to_rfc2822()
        )
    }
}

impl<'a> ChangelogEntry<'a> {
    pub fn new(
        src: &'a str,
        version: &'a str,
        distribution: &'a str,
        urgency: &'a str,
        maintainer: &'a str,
        items: &[String],
    ) -> Self {
        let changelog = items.iter().map(|x| x.to_string());
        ChangelogEntry {
            source: src,
            version: version,
            distribution: distribution,
            urgency: urgency,
            maintainer: maintainer,
            items: Vec::from_iter(changelog),
        }
    }
}

pub struct ChangelogIterator<'a> {
    input: &'a [u8],
    index: usize,
}

impl<'a> ChangelogIterator<'a> {
    pub fn from(input: &'a str) -> ChangelogIterator<'a> {
        ChangelogIterator {
            input: input.as_bytes(),
            index: 0,
        }
    }
}

impl<'a> Iterator for ChangelogIterator<'a> {
    type Item = &'a str;

    #[inline]
    fn next(&mut self) -> Option<&'a str> {
        let slice = &self.input[self.index..];
        if slice.is_empty() {
            return None;
        }
        let mut result = slice;
        // ghetto parser; also hack around the fact rust's str doesn't
        // support proper indexing, boo
        for (i, c) in slice.iter().enumerate() {
            if *c != ('\n' as u8) {
                continue;
            }
            if slice.len() >= i || (slice[i + 1] as char).is_whitespace() {
                continue;
            }
            self.index += i + 1;
            result = &slice[..i + 1];
            break;
        }
        Some(str::from_utf8(&result).unwrap())
    }
}
